# Kitu Logic Processor

Kitu は **Rust バックエンド + Unity クライアント** という構成で、決定的（deterministic）なゲームロジックと、高速な開発サイクル、開発者体験の向上を重視したフレームワークです。


## Table of Contents
- [はじめに](#はじめに)
- [アーキテクチャ概要](#アーキテクチャ概要)
- [クレート一覧](#クレート一覧)
- [バックエンドゲームロジック（Rust）](#バックエンドゲームロジックrust)
- [通信レイヤー（OSC + osc-ir + MessagePack）](#通信レイヤーosc--osc-ir--messagepack)
- [Unity クライアント（表現レイヤー）](#unity-クライアント表現レイヤー)
- [Kitu Shell](#kitu-shell)
- [データシステム（TMD + SQLite）](#データシステムtmd--sqlite)
- [タイムラインとオートメーション（TSQ1）](#タイムラインとオートメーションtsq1)
- [Web Admin ツール](#web-admin-ツール)
- [開発ワークフロー](#開発ワークフロー)
- [デプロイと配布](#デプロイと配布)
- [ロードマップ（未定）](#ロードマップ未定)

## はじめに

Kitu では、**ゲームロジック（Rust バックエンド）** と **表現（Unity）** を明確に分離します。

- Rust バックエンド: ECS, タイムライン（TSQ1）, スクリプト（Rhai）, データ（TMD/SQLite）など「ゲームの頭脳」
- Unity: レンダリング・オーディオ・UI・入力 → すべてイベントに基づく「表現レイヤー」

主なゴール:

- シングルプレイであってもサーバーオーソリタティブな決定的シミュレーション
- Unity を「見た目と入力」に集中させる
- OSC / osc‑ir を使ったゆるやかなイベント駆動連携
- データ・スクリプトのホットリロードによる高速な試行錯誤
- Shell / Web Admin / CI などの強力なツール群
- ロジック・アート・デザイン・QA などの職能を疎結合にする


## アーキテクチャ概要

Kitu の主な構成要素:

- **Rust バックエンド**
  - ECS ベースのシミュレーション
  - Rhai によるゲームロジック DSL
  - TSQ1 タイムライン再生
  - TMD + SQLite によるマスターデータ管理
  - 高精度タイマーによるゲームループと決定的実行
- **Unity クライアント**
  - 受け取った OSC イベントに応じて描画・UI・サウンドを更新
  - 入力を OSC イベントとしてバックエンドに送信
  - Addressables による動的アセットロード
  - ゲームルールは一切持たない
- **通信レイヤー**
  - osc‑ir データモデル（OSC 互換 IR）
  - 組み込み時はネイティブ構造体 / ネットワーク時は MessagePack
- **ツール群**
  - Kitu Shell（CLI コンソール）
  - Web Admin（ブラウザ UI）
  - CI / リプレイ / 自動化スクリプト

責務の分離・決定性・データ駆動・イベント駆動が設計の柱です。

## クレート一覧

`crates/` 以下の Rust クレートの役割をまとめた一覧は [doc/crates-overview.md](doc/crates-overview.md) を参照してください（英語）。


## バックエンドゲームロジック（Rust）

Rust バックエンドは Kitu の「ゲーム宇宙」を一手に引き受けます。

主な役割:

- ECS によるエンティティ / コンポーネント / システム
- 高精度タイマーに基づくゲームループ
- Unity や Web Admin からの OSC 入力イベント処理
- Rhai スクリプトの実行（スキル・クエスト・AI など）
- TSQ1 タイムラインの再生
- TMD / SQLite データの読み込みとバリデーション
- Unity / Web Admin などへの OSC 出力イベント生成

実行形態:

- **スタンドアロンバイナリ**（開発・マルチプレイ・CI 向け）
- **cdylib として Unity に組み込み**（オフライン / シングルプレイ）

いずれも同じロジックコードを用いるため、挙動は完全に一致します。


## 通信レイヤー（OSC + osc-ir + MessagePack）

Kitu の各コンポーネントは **OSC 風のイベント** と **osc‑ir データモデル** でやり取りします。

- OSC: `/input/move`, `/game/spawn`, `/ui/dialog` のような階層的アドレス
- osc‑ir: 型付きでシリアライズしやすい中間表現
- 組み込みモード: ネイティブ構造体 / バイト列でやりとり
- ネットワークモード: MessagePack でエンコードし WebSocket / TCP で送信

代表的な流れ:

- Unity → バックエンド: `/input/*` や UI 操作、デバッグコマンド
- バックエンド → Unity: `/render/*`, `/ui/*`, タイムライン由来イベント
- Web Admin ↔ バックエンド: `/debug/*` を含む各種制御・監視イベント

このイベント駆動レイヤーにより疎結合で柔軟な構成が実現できます。


## Unity クライアント（表現レイヤー）

Unity は純粋な **表現・入力レイヤー** として扱います。

- MonoBehaviour にゲームルールを書かない
- `/render/*` イベントに応じて GameObject の生成 / 破棄 / アニメーション / VFX / UI を制御
- 入力を `/input/*` イベントとしてバックエンドに送信
- Addressables 経由でアセットを動的ロード

Unity の責務:

- 3D/2D 表現・シェーダ・VFX・ライティング
- オーディオ再生
- UI レンダリング（HUD/メニュー/ダイアログ）
- 画面 / シーン遷移
- Addressables によるアセット管理

これにより Unity 側の設計が大幅にシンプルになります。


## Kitu Shell

Kitu Shell はランタイムと対話する **開発者向けコンソール** です。

接続先:

- ローカルスタンドアロンバックエンド
- ネットワーク越しのリモートバックエンド
- Unity 組み込みバックエンド（ブリッジ経由）
- Web Admin 内ブラウザシェル

できること:

- エンティティやコンポーネントの一覧・詳細表示
- TSQ1 タイムラインの再生 / シーク / 停止
- 開発用のデータ変更
- 任意の OSC イベント送信（`send /game/spawn_enemy { ... }` など）
- シナリオスクリプト実行・リプレイ
- 決定的な動作ログに組み込まれる形でのデバッグ

コマンドは拡張可能で、すべて安全なイベント経由でロジックに反映されます。


## データシステム（TMD + SQLite）

Kitu は徹底した **データ駆動設計** を採用します。

- **Tanu Markdown (TMD)**:
  - ユニット・アイテム・スキル・クエスト・設定値などのマスターデータ
  - 人間が読みやすく Git で管理しやすい
  - ベース / 難易度別 / イベント用 / デバッグ用 などのレイヤー構造
- **SQLite**:
  - 大規模・リレーショナルなデータ（カタログ・ローカライズ・グラフ構造など）

バックエンドは:

- 起動時またはホットリロード時にデータを読み込み・検証
- エラーをログ / Shell / Web Admin 経由で通知
- システムやスクリプトから型安全にアクセス可能

Unity は原則として生データを直接読まず、バックエンドからの結果に基づいて表現します。


## タイムラインとオートメーション（TSQ1）

TSQ1 は Kitu の **最小限で決定的なタイムラインフォーマット** です。

- 時間順に並んだイベント（トラック・マーカー・メタデータ付き）
- カットシーン・UI トランジション・スクリプトシーケンス・自動テストなどに利用
- 実行はすべてバックエンド側で行い、Unity は結果イベントのみを受け取る

重要なポイント: **TSQ1 自体は Tween / 補間 / イージングを定義しません。**
補間はアプリケーション側（バックエンドや Unity の解釈レイヤー）で実装します。

- カメラや UI の補間器が「duration 付き move_to」イベントなどを解釈
- 線形 / イーズ / ブレンドなどはコード側の責務
- TSQ1 はあくまで「いつ」「どのイベントを発火するか」を記述するだけ

TSQ1 は TMD やスクリプトから生成でき、将来的にはビジュアルエディタとも連携する想定です。


## Web Admin ツール

Web Admin はブラウザからアクセスできる **バックエンド管理・デバッグ UI** です。

- ローカル / リモートどちらのバックエンドにも接続可能
- ダッシュボード・ECS インスペクタ・タイムラインビュー・ミニマップ・ログ・メトリクスなどを提供
- ブラウザ版 Kitu Shell を内蔵
- 認証・権限制御により安全に運用可能

主な機能:

- エンティティ / コンポーネントのリアルタイム閲覧・一部編集（開発環境）
- タイムライン再生状況の確認とシーク
- ミニマップによるワールド状態の可視化
- イベントストリーム / ログの監視
- Rhai スクリプトや Shell コマンドの実行
- Live Ops 向けの運用操作（将来的な拡張）

これにより Unity を起動せずとも、ゲームサーバの状態を詳細に観察し制御できます。


## 開発ワークフロー

Kitu の開発フローは **高速な反復と責務分離** を重視しています。

- バックエンド開発者:
  - Rust / Rhai でロジック実装・テスト
  - ヘッドレスでシミュレーション動作を確認
- Unity 開発者:
  - 見た目・UI・エフェクト・Addressables を担当
- デザイナー:
  - TMD / TSQ1 / DB コンテンツの編集
  - Web Admin / Shell で状態を確認
- QA / 自動化:
  - シナリオリプレイ・決定的テスト・負荷テスト

典型的なループ:

1. バックエンド起動（スタンドアロン or Unity 組み込み）
2. 必要に応じて Unity を起動して視覚的に確認
3. TMD / TSQ1 / DB / Rhai を編集
4. バックエンドがホットリロード
5. Shell / Web Admin で状態や挙動を確認
6. 問題なければコミット

CI では Unity を起動せず、バックエンドのみでシナリオテストや性能チェックが可能です。


## デプロイと配布

Kitu はさまざまなデプロイ形態をサポートします。

- **シングルプレイ / オフライン**:
  - バックエンドを cdylib として Unity に組み込み
  - ローカル SQLite / TMD をクライアント同梱
- **クライアント–サーバ型マルチプレイ**:
  - バックエンドをスタンドアロンバイナリとしてサーバに配置（Docker/K8s/VM 等）
  - Unity クライアントは WebSocket + MessagePack で接続
  - Web Admin を公開し、運用・デバッグをブラウザから実施
- **ハイブリッド**:
  - オフラインでも動作し、オンライン時は追加機能を解放
  - バックエンドは組み込み / リモートいずれも同じイベントプロトコルを使用

その他:

- Addressables を CDN で配信し、Git ハッシュやビルド ID でバージョン管理
- データ（TMD / TSQ1）はクライアント同梱 / サーバ側のみ の両方に対応
- CI/CD パイプラインでバックエンド・クライアント・バンドル・データをビルド・デプロイ
- クライアントとバックエンドのバージョン互換性チェック


## ロードマップ（未定）

Kitu の詳細なロードマップは現在検討中です。今後の方向性としては、おおむね次のような領域が想定されています。

- Web Admin の可視化・エディタ機能の拡充（TSQ1 / ECS / AI / クエストなど）
- Unity エディタ拡張や VSCode 連携による開発体験の向上
- より高度なマルチプレイ・シャーディングモデル
- バランス調整やプレイテストの自動化・半自動化
- 代表的なゲームジャンル向けテンプレート（アクションRPG / SRPG / NVL など）

具体的なマイルストーンやバージョン計画は、アーキテクチャとワークフローが実プロジェクトで十分に検証された段階で公開される予定です。


Kitu は、Rust と Unity を組み合わせた **モダンでデータ駆動なゲーム開発基盤** を目指しています。
この README はアーキテクチャの俯瞰を提供するものであり、各クレート・Unity パッケージ・ツールごとに、より詳細な API ドキュメントや実装ガイドが別途用意される想定です。
